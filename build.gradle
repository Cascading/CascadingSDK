/*
 * Copyright (c) 2007-2013 Concurrent, Inc. All Rights Reserved.
 *
 * Project and contact information: http://www.concurrentinc.com/
 */

import org.apache.tools.ant.filters.ReplaceTokens

import java.text.SimpleDateFormat

import com.monochromeroad.gradle.plugin.aws.s3.S3Sync
import com.monochromeroad.gradle.plugin.aws.s3.ACL

if( project.properties[ 'teamcity' ] ) // make them system properties
  System.properties.putAll( project.properties[ 'teamcity' ] )

if( System.properties[ 'aws.properties' ] )
{
  file( System.properties[ 'aws.properties' ] ).withReader { reader ->
    def awsProperties = new Properties()
    awsProperties.load( reader )
    System.properties.putAll( awsProperties )
  }
}

ext.majorVersion = 2.2
ext.applicationGroup = "sdk"
ext.applicationName = "Cascading-${majorVersion}-SDK"
ext.timestamp = new SimpleDateFormat( "yyyyMMdd" ).format( new Date() )
ext.archiveBaseName = "${applicationName}-${timestamp}"
ext.distDir = "${buildDir}/dist/${archiveBaseName}"
ext.distributionDir = "${buildDir}/distribution"

ext.sourceBucket = System.getProperty("source.bucket")  ?: "files.concurrentinc.com"
ext.docSourceBucket = System.getProperty("doc.source.bucket") ?: "docs.concurrentinc.com"

configurations {
  s3AntTask
}

buildscript {
  repositories {
    mavenCentral()
    mavenLocal()
    mavenRepo name: 'conjars', url: 'http://conjars.org/repo'
    // XXX put this back in, as soon as upstream has a new release
    //mavenRepo name: 'monochromeroad', url: 'http://repository-monochromeroad.forge.cloudbees.com/release/'
  }
  dependencies {
    /// XXX change back to original group id after new upstream release
    classpath group: 'thirdparty', name: "gradle-aws-s3-sync", version: '0.5.1'
  }
}

allprojects {
  repositories {
    mavenLocal()
    mavenCentral()
    mavenRepo name: 'conjars', url: 'http://conjars.org/repo/'
  }
}

task copyEnv( type: Copy ) {
  from 'etc/setenv.sh'
  into "${distDir}/etc"
}

task copyEnvD( type: Copy ) {
  from 'etc/env.d'
  into "${distDir}/etc/env.d"
}

task copyEMRScript(type: Copy){
    from fileTree("etc/emr")
    into distributionDir
}

copyEnv.doFirst() {
  mkdir "${distDir}/etc"

  def binPaths = [ ]

  fileTree( distDir ) {
    include '*/*/bin/'
  }.visit { element ->
    if( element.isDirectory() && element.getName().equals( 'bin' ) )
      binPaths << element.getRelativePath()
  }

  def pathString = binPaths.collect { path -> "\${CASCADING_SDK_HOME}/${path}" }.join( ':' )

  filter( ReplaceTokens, tokens: [ BIN_PATHS: pathString ] )
}

task copySupport( type: Copy, dependsOn: [copyEnv, copyEnvD] ) {
  from 'README.md'
  into distDir
}

task packageDist( type: Tar, dependsOn: copySupport ) {
  description = 'Creates the sdk archive.'

  baseName = applicationName
  version = timestamp
  compression = "GZIP"
  destinationDir = file( distributionDir )
  from "${buildDir}/dist/"
}

allprojects {
  task clean( type: Delete ) {
    delete buildDir
  }
}

subprojects {

  ext.distDir = "${buildDir}/dist"

  task fetchLatest {
    ext.latestURL = null
    ext.distroURL = null
    ext.typePath = ''

    outputs.dir distDir
  }

  fetchLatest.onlyIf { fetchLatest.latestURL != null || fetchLatest.distroURL != null }

  fetchLatest << {

    mkdir buildDir
    mkdir distDir

    if( distroURL == null )
    {
      def latestFile = new File( buildDir, 'LATEST.TXT' )

      ant.get( src: latestURL, dest: latestFile.absolutePath, skipexisting: false )

      distroURL = latestFile.readLines()[ 0 ]
    }

    def distroZip = new File( buildDir, distroURL.substring( distroURL.lastIndexOf( '/' ) ) )

    ant.get( src: distroURL, dest: distroZip.absolutePath, skipexisting: true )

    ext.typeDir = new File( distDir, typePath )
    mkdir typeDir

    if( distroURL.endsWith( 'zip' ) || distroURL.contains( 'zipball' ) )
      ant.unzip( src: distroZip, dest: typeDir )
    else
      ant.untar( src: distroZip, dest: typeDir, compression: 'gzip' )
  }

  task distCopy( type: Copy, dependsOn: fetchLatest ) {
    from( distDir )
    into( rootProject.distDir )

    rootProject.tasks[ 'packageDist' ].dependsOn << distCopy
    rootProject.tasks[ 'copyEnv' ].dependsOn << distCopy
  }
}

// publishing code

task createArchiveLatest( dependsOn: packageDist ) {

  ext.latestArchivePath = null
}

createArchiveLatest << {

  def publishBucket = System.properties[ 'publish.bucket' ] ?:  "files.concurrentinc.com"
  def releaseTar = packageDist.archiveName

  assert publishBucket

  latestArchivePath = new File( distributionDir, 'latest.txt' )
  latestArchivePath.write( "http://${publishBucket}/${applicationGroup}/${majorVersion}/${releaseTar}" )
}


task s3Upload(type: S3Sync,  dependsOn: [copyEMRScript, createArchiveLatest] ){

  accessKey = System.properties[ 'publish.aws.accessId' ]
  secretKey = System.properties[ 'publish.aws.secretKey' ]

  acl ACL.PublicRead

  def s3Bucket = System.properties[ 'publish.bucket' ] ?: "files.concurrentinc.com"

  // XXX this should probably be enabled, but it is off for now to ease development
  //assert accessKey
  //assert secretKey
  //assert s3Bucket
  
  keepFiles = true

  configFile = "${rootProject.projectDir}/etc/synchronizer.properties"

  into "${s3Bucket}/${applicationGroup}/${majorVersion}/"
  from distributionDir

}
